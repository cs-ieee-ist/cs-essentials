# GDB - Debug with core files

A Core dump is a file containing a process's address space (memory) when the process terminates unexpectedly. This file is very usefull for debugging, for example, segmentation faults.

## Generate a Core Dump file

Most systems, by default, have the core dump file generation disabledMost systems, by default, have the core dump file generation disable. We can check by running the following command:
8
. We can check by running the following command:

```bash
~ $ ulimit -c
0
```

To enable the creation we need to run the following commands:

```bash
~ $ ulimit -c unlimited
```

## The program

To examplify how you can use the Core Dump and the GDB to debug we will use this program:

```c
int main() {
        char* s = 0;
        char c = s[0];
        return 0;
}
```

Now we can compile and run the program.

```bash
~ $ gcc -g example.c
~ $ ./a.out
Segmentation fault (core dumped)
```

Make sure that the Core Dump file was created, you can use the "ls" command.

## Debug

Now that we have the core file we can start trying to understand the problem.

### Open GDB

```bash
~ $ gdb a.out core
Core was generated by `./a.out'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000563a5b9f160a in nullPtr () at hello.c:3
3		char c = s[0];
```

The first thing we are going to do is use the "backtrace" command. A program when running maintains a call stack that contains information about the functions that have been called so far. Each item in the stack is a call frame, and each frame contains both the information needed to return to its caller and the information needed to provide the local variables of the function. Backtrace is used get a stack trace from the time when the sigsegv was raised. Each frame in the stack has a number, where 0 is the most recent call. 

```bash
(gdb) bt
#0  0x0000563a5b9f160a in nullPtr () at hello.c:3
#1  0x0000563a5b9f1621 in main () at hello.c:7
```

This example is trivial, but in normal cases this backtrace essential and gives the programmer a good idea of what the problem might be.

In some cases it might be useful to use the "frame" command, this gives us more information about each frame. For example the frame 0:

```bash
(gdb) frame 0
#0  0x0000563a5b9f160a in nullPtr () at hello.c:3
3		char c = s[0];
```

This information is the same given by the debugger when we started. This is due to the fact that the operation "s[0]" is trying to access an invalid memory position (0x0).


