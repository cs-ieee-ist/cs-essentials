<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content=""/><meta property="og:image" content="https://og-image.now.sh/CS%20Essentials%20by%20IEEE-IST%20CS.png?theme=light&amp;md=0&amp;fontSize=75px&amp;images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fnextjs-black-logo.svg"/><meta name="og:title" content="CS Essentials by IEEE-IST CS"/><meta name="twitter:card" content="summary_large_image"/><title>Valgrind - Memory Leaks</title><meta name="next-head-count" content="8"/><meta name="description" content="This is a repository that helps students, from any area, learn and practice with CS-related tools. For example, Vim, Gdb and Git. Our goal is to help students being more proficient and efficient using these tools."/><meta property="og:image" content="/images/cs-essentials-thumb.png"/><link rel="preload" href="/cs-essentials/_next/static/css/e817f30db9e2fbc9.css" as="style"/><link rel="stylesheet" href="/cs-essentials/_next/static/css/e817f30db9e2fbc9.css" data-n-g=""/><link rel="preload" href="/cs-essentials/_next/static/css/4ac378de523de276.css" as="style"/><link rel="stylesheet" href="/cs-essentials/_next/static/css/4ac378de523de276.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/cs-essentials/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/cs-essentials/_next/static/chunks/webpack-da1def9bc0e14471.js" defer=""></script><script src="/cs-essentials/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/cs-essentials/_next/static/chunks/main-22ca3ce31bc8f472.js" defer=""></script><script src="/cs-essentials/_next/static/chunks/pages/_app-ae657964cf53a525.js" defer=""></script><script src="/cs-essentials/_next/static/chunks/545-ebf1732b65004e76.js" defer=""></script><script src="/cs-essentials/_next/static/chunks/pages/content/%5Btopic%5D/%5Bpage%5D-446e7cc15de98dac.js" defer=""></script><script src="/cs-essentials/_next/static/LYyRVvNwNYLo0ckHfDevq/_buildManifest.js" defer=""></script><script src="/cs-essentials/_next/static/LYyRVvNwNYLo0ckHfDevq/_ssgManifest.js" defer=""></script><script src="/cs-essentials/_next/static/LYyRVvNwNYLo0ckHfDevq/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="layout_container__fbLkO"><header class="layout_header__kY0Lt"><div class="layout_headerLeft__0b4ue"><a class="layout_headerLogoLink__zvo0e" href="/cs-essentials"><img class="layout_headerLogo___MlhX" src="/cs-essentials/images/logo-cs.png" alt="logo"/></a></div><div class="layout_headerSearch__IC688"><input placeholder="Search"/><a class="layout_headerSearchBtn__qOMwZ" href="/cs-essentials/search?query="><img src="/cs-essentials/icons/search.svg"/></a></div><div class="layout_headerRight__uMd64"><span class="layout_headerIcon__npohY layout_headerSearchIcon__XMKkx"><img src="/cs-essentials/icons/search.svg" alt="search-icon"/></span><a class="layout_headerIcon__npohY" target="_blank" rel="noopener noreferrer" href="https://github.com/cs-ieee-ist/cs-essentials/"><img src="/cs-essentials/icons/logo--github.svg" alt="info-icon"/></a><a class="layout_headerIcon__npohY" href="/cs-essentials/about"><img src="/cs-essentials/icons/information.svg" alt="info-icon"/></a></div></header><div class="layout_mainContent__lKvHP"><div class="layout_backToHome__9sjx_"><a href="/cs-essentials"><img src="/cs-essentials/icons/chevron--left.svg" alt="back-icon"/><span>Back to Home</span></a></div><main><div class="layout_contentContainer__QmgPN"><div class="content_pageContentContainer__ezTWH"><div class=" layout_contentSidebar__4H9xF"><ul class="layout_sidebarList__zIGeA"><li class="layout_sidebarItem__0q7WW "><a href="/cs-essentials/content/valgrind/Introduction">Introduction</a></li><li class="layout_sidebarItem__0q7WW "><a href="/cs-essentials/content/valgrind/Basic%20Example">Basic Example</a></li><li class="layout_sidebarItem__0q7WW layout_active__YGCU_"><a href="/cs-essentials/content/valgrind/Memory%20Leaks">Memory Leaks</a></li></ul></div><div class=" cards_contentCard__cZDDp"><article class="cards_contentArticle__O4OZ4"><div><h1>Detecting Memory Leaks</h1>
<p>Memcheck keeps track of all heap blocks issued in response to calls to <code>malloc</code>/<code>new</code> (for C/C++, respectively) et al. Thus, when the program exits, Memcheck knows which blocks have not been freed.</p>
<h3>Basic memory leak example</h3>
<p>Let's consider the following code:</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-type">char</span> *my_str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">42</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Let's compile it with:
<code>gcc -g -o my-prog main.c</code>
By omission, this is how we're going to compile our files going forward.</p>
<p>Running the program:</p>
<p><code>valgrind ./my-prog</code></p>
<p>We get the following output:</p>
<pre><code class="hljs language-ini">...
==<span class="hljs-attr">6283</span>== HEAP SUMMARY:
==<span class="hljs-attr">6283</span>==     in use at exit: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">6283</span>==   total heap usage: <span class="hljs-number">1</span> allocs, <span class="hljs-number">0</span> frees, <span class="hljs-number">42</span> bytes allocated
==<span class="hljs-attr">6283</span>== 
==<span class="hljs-attr">6283</span>== LEAK SUMMARY:
==<span class="hljs-attr">6283</span>==    definitely lost: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">6283</span>==    indirectly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6283</span>==      possibly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6283</span>==    still reachable: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6283</span>==         suppressed: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6283</span>== Rerun with --leak-check=full to see details of leaked memory
==<span class="hljs-attr">6283</span>== 
==<span class="hljs-attr">6283</span>== For counts of detected and suppressed errors, rerun with: -v
==<span class="hljs-attr">6283</span>== ERROR SUMMARY: <span class="hljs-number">0</span> errors from <span class="hljs-number">0</span> contexts (suppressed: <span class="hljs-number">0</span> from <span class="hljs-number">0</span>)
...
</code></pre>
<p>Memcheck lets us know about the obvious memory leak: we allocated 42 bytes, since <code>sizeof(char) == 1</code> (section 6.5.3.5 of the specification), which we didn't free.
Valgrind recommends the use of the <code>--leak-check=full</code>. By using that option we'll get useful information that'll help us solve memory leaks.</p>
<p>Let's then rerun the program with <code>--leak-check=full</code>:</p>
<p><code>valgrind --leak-check=full ./my-prog</code></p>
<p>This is the output:</p>
<pre><code class="hljs language-ini">...
==<span class="hljs-attr">6303</span>== HEAP SUMMARY:
==<span class="hljs-attr">6303</span>==     in use at exit: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">6303</span>==   total heap usage: <span class="hljs-number">1</span> allocs, <span class="hljs-number">0</span> frees, <span class="hljs-number">42</span> bytes allocated
==<span class="hljs-attr">6303</span>== 
==<span class="hljs-attr">6303</span>== <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks are definitely lost in loss record <span class="hljs-number">1</span> of <span class="hljs-number">1</span>
==<span class="hljs-attr">6303</span>==    at <span class="hljs-number">0</span>x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==<span class="hljs-attr">6303</span>==    by <span class="hljs-number">0</span>x10865B: main (main.c:<span class="hljs-number">5</span>)
==<span class="hljs-attr">6303</span>== 
==<span class="hljs-attr">6303</span>== LEAK SUMMARY:
==<span class="hljs-attr">6303</span>==    definitely lost: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">6303</span>==    indirectly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6303</span>==      possibly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6303</span>==    still reachable: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6303</span>==         suppressed: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6303</span>== 
==<span class="hljs-attr">6303</span>== For counts of detected and suppressed errors, rerun with: -v
==<span class="hljs-attr">6303</span>== ERROR SUMMARY: <span class="hljs-number">1</span> errors from <span class="hljs-number">1</span> contexts (suppressed: <span class="hljs-number">0</span> from <span class="hljs-number">0</span>)
...
</code></pre>
<p>How cool is this? Valgrind was able to tell us exactly where the un<code>free</code>d memory was! Now, this is obviously a very simple program and you can tell where the leak is right away, but that won't always be the case. I <strong>assure</strong> you.</p>
<p>Let's correct our program then!</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-type">char</span> * my_str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">42</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));

	<span class="hljs-built_in">free</span>(my_str);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>The output will now look like this:</p>
<pre><code class="hljs language-ini">...
==<span class="hljs-attr">7101</span>== HEAP SUMMARY:
==<span class="hljs-attr">7101</span>==     in use at exit: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">7101</span>==   total heap usage: <span class="hljs-number">1</span> allocs, <span class="hljs-number">1</span> frees, <span class="hljs-number">42</span> bytes allocated
==<span class="hljs-attr">7101</span>== 
==<span class="hljs-attr">7101</span>== All heap blocks were freed -- <span class="hljs-literal">no</span> leaks are possible
==<span class="hljs-attr">7101</span>== 
==<span class="hljs-attr">7101</span>== For counts of detected and suppressed errors, rerun with: -v
==<span class="hljs-attr">7101</span>== ERROR SUMMARY: <span class="hljs-number">0</span> errors from <span class="hljs-number">0</span> contexts (suppressed: <span class="hljs-number">0</span> from <span class="hljs-number">0</span>)
...
</code></pre>
<p>Great, now we know how to look for memory leaks!</p>
<h3>Kinds of memory leaks</h3>
<p>Let's take a look at an excerpt from the above example:</p>
<pre><code class="hljs language-ini">==<span class="hljs-attr">6303</span>== LEAK SUMMARY:
==<span class="hljs-attr">6303</span>==    definitely lost: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">6303</span>==    indirectly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6303</span>==      possibly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">6303</span>==    still reachable: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
</code></pre>
<p>This little snippet includes the four types of leaks than may occur in your programs:</p>
<ul>
<li>"Still reachable" - The block is still pointed at, so the programmer, in principle, could have freed it before program exit. They're very common, so by default won't report such blocks individually.</li>
<li>"Definitely lost" - No pointer to the block can be found. The block is classified as "lost" because the programmer could not possibly have freed it at program exit, since no pointer to it exists. This is a symptom of the pointer being lost at some earlier point in the program. Such cases should be fixed by the programmer.</li>
<li>"Indirectly lost" - The block is lost, not because there are no pointers to it, but rather because all the blocks that point to it are themselves lost. For example, if you have a binary tree and the root node is lost, all is children nodes will be indirectly lost.</li>
<li>"Possibly lost" - This means that one or more pointers to the block have been found, but at least one of them is an interior-pointer (i.e. a pointer to the middle of the block).</li>
</ul>
<p>In the example at the start of this section, the 42 bytes we allocated were "definitely lost" because, after returning from <code>main</code>, the lifetime of <code>my_str</code> ends. As a result, there is no longer a reference to the pointer to the 42 bytes of allocated memory.</p>
<h3>"Definitely lost" memory</h3>
<p>The previous example demonstrated a case of "definitely lost" memory, but let's take a look at another example:</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	<span class="hljs-type">char</span> *my_str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">42</span>);
	my_str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);

	<span class="hljs-built_in">free</span>(my_str);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>In this case, those first 42 bytes are "definitely lost" because the pointer value is overwritten to the newly allocated 100 bytes; and so, there is no longer any reference to the first block of memory we allocated.</p>
<h3>"Still reachable" memory</h3>
<p>Sometimes, this kind of leak is confused with "definitely lost" memory because one might think that (considering the first example in this section) <code>my_str</code>, the pointer to the allocated memory, could have been used to free it.</p>
<p>However, the program doesn't end with <code>main</code> returning. After <code>main</code> returning, both global and static variables still live on, thus allowing cleanup routines (such as <a href="https://www.man7.org/linux/man-pages/man3/atexit.3.html"><code>atexit</code></a>) to clean up memory pointed to by those variables. Let's take a look at an example:</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">char</span> *my_str;

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	my_str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">42</span>);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Valgrind tells us this:</p>
<pre><code class="hljs language-ini">...
==<span class="hljs-attr">25767</span>== HEAP SUMMARY:
==<span class="hljs-attr">25767</span>==     in use at exit: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">25767</span>==   total heap usage: <span class="hljs-number">1</span> allocs, <span class="hljs-number">0</span> frees, <span class="hljs-number">42</span> bytes allocated
==<span class="hljs-attr">25767</span>== 
==<span class="hljs-attr">25767</span>== LEAK SUMMARY:
==<span class="hljs-attr">25767</span>==    definitely lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">25767</span>==    indirectly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">25767</span>==      possibly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">25767</span>==    still reachable: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">25767</span>==         suppressed: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
...
</code></pre>
<p>Since <code>my_str</code> is a global variable, it is still "alive" after <code>main</code> returning, so we still have a reference to the allocated 42 bytes. We can free that memory after returning from <code>main</code> by using a method such as the aforementioned <code>atexit</code>:</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">char</span> *my_str;

<span class="hljs-type">void</span> <span class="hljs-title hljs-function">cleanup</span><span class="hljs-params">()</span> {
	<span class="hljs-built_in">free</span>(my_str);
}

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	atexit(cleanup);

	my_str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">42</span>);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3>"Possibly lost" memory</h3>
<p>As stated before, what causes Valgrind to tell us about "possibly lost" memory is the existance of an interior-pointer to an allocated block.</p>
<p>That can be the result of libraries which have their own allocators and for which the pointer to the allocated memory is not the pointer returned by the OS itself (via the <code>malloc</code> library function or the <code>sbrk</code> system call) but a pointer with some offset.</p>
<p>An example of a program that produces such a warning from Valgrind is as such:</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">char</span> *my_str;

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	my_str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">42</span>);
	<span class="hljs-comment">/* At this point, the pointer points to the start
	of the allocated memory. */</span>

	my_str += <span class="hljs-number">20</span>;
	<span class="hljs-comment">/* At this point, no pointer points to the start of
	the allocated memory. However, it is still accessible. */</span>

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Valgrind tells us about the "possibly lost" memory:</p>
<pre><code class="hljs language-ini">...
==<span class="hljs-attr">29630</span>== HEAP SUMMARY:
==<span class="hljs-attr">29630</span>==     in use at exit: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">29630</span>==   total heap usage: <span class="hljs-number">1</span> allocs, <span class="hljs-number">0</span> frees, <span class="hljs-number">42</span> bytes allocated
==<span class="hljs-attr">29630</span>== 
==<span class="hljs-attr">29630</span>== <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks are possibly lost in loss record <span class="hljs-number">1</span> of <span class="hljs-number">1</span>
==<span class="hljs-attr">29630</span>==    at <span class="hljs-number">0</span>x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==<span class="hljs-attr">29630</span>==    by <span class="hljs-number">0</span>x108657: main (main.c:<span class="hljs-number">7</span>)
==<span class="hljs-attr">29630</span>== 
==<span class="hljs-attr">29630</span>== LEAK SUMMARY:
==<span class="hljs-attr">29630</span>==    definitely lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">29630</span>==    indirectly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">29630</span>==      possibly lost: <span class="hljs-number">42</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">29630</span>==    still reachable: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">29630</span>==         suppressed: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
...
</code></pre>
<p>To free a memory block we need the address of that memory block. So in this case, all we have to do is take into the pointer offset and get to the start of the allocated block:</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">char</span> *my_str;

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	my_str = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">42</span>);
	<span class="hljs-comment">/* At this point, the pointer points to the start
	of the allocated memory. */</span>

	my_str += <span class="hljs-number">20</span>;
	<span class="hljs-comment">/* At this point, no pointer points to the start of
	the allocated memory. However, it is still accessible. */</span>

	<span class="hljs-built_in">free</span>(my_str - <span class="hljs-number">20</span>);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>And now the leak is gone!</p>
<h3>"Indirectly lost"</h3>
<p>Reiterating on what was said up there, "indirectly lost" memory doesn't mean that there are no pointers to it, but rather because all the blocks that point to it are themselves lost.</p>
<p>Here is a simple example:</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">int</span> ***arr;

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	arr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>**));

	arr[<span class="hljs-number">2</span>] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*));

	arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));

	<span class="hljs-built_in">free</span>(arr);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>Which produces the following output in Valgrind:</p>
<pre><code class="hljs language-ini">...
==<span class="hljs-attr">30154</span>== HEAP SUMMARY:
==<span class="hljs-attr">30154</span>==     in use at exit: <span class="hljs-number">440</span> bytes in <span class="hljs-number">2</span> blocks
==<span class="hljs-attr">30154</span>==   total heap usage: <span class="hljs-number">3</span> allocs, <span class="hljs-number">1</span> frees, <span class="hljs-number">480</span> bytes allocated
==<span class="hljs-attr">30154</span>== 
==<span class="hljs-attr">30154</span>== <span class="hljs-number">440</span> (<span class="hljs-number">40</span> direct, <span class="hljs-number">400</span> indirect) bytes in <span class="hljs-number">1</span> blocks are definitely lost in loss record <span class="hljs-number">2</span> of <span class="hljs-number">2</span>
==<span class="hljs-attr">30154</span>==    at <span class="hljs-number">0</span>x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==<span class="hljs-attr">30154</span>==    by <span class="hljs-number">0</span>x1086B8: main (main.c:<span class="hljs-number">9</span>)
==<span class="hljs-attr">30154</span>== 
==<span class="hljs-attr">30154</span>== LEAK SUMMARY:
==<span class="hljs-attr">30154</span>==    definitely lost: <span class="hljs-number">40</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">30154</span>==    indirectly lost: <span class="hljs-number">400</span> bytes in <span class="hljs-number">1</span> blocks
==<span class="hljs-attr">30154</span>==      possibly lost: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">30154</span>==    still reachable: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
==<span class="hljs-attr">30154</span>==         suppressed: <span class="hljs-number">0</span> bytes in <span class="hljs-number">0</span> blocks
...
</code></pre>
<p>We can fix this by appropriately freeing the allocated blocks:</p>
<pre><code class="hljs language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;stdlib.h></span></span>

<span class="hljs-type">int</span> ***arr;

<span class="hljs-type">int</span> <span class="hljs-title hljs-function">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>
{
	arr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>**));

	arr[<span class="hljs-number">2</span>] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*));

	arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));

	<span class="hljs-built_in">free</span>(arr[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]);
	<span class="hljs-built_in">free</span>(arr[<span class="hljs-number">2</span>]);
	<span class="hljs-built_in">free</span>(arr);

	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>There you go, now you should have the tools to check your programs for memory leaks!</p></div><a class="layout_editLink__B6YqJ" href="https://github.com/cs-ieee-ist/cs-essentials/tree/master/content/topics/valgrind/2-Memory Leaks.md" target="_blank" rel="noreferrer noopener"><img src="/cs-essentials/icons/edit.svg" alt="edit-icon"/>Edit this page</a></article></div><div class="content_dummySidebar__UTBtD"></div></div></div></main></div><footer class="layout_footer__dka_2"><span class="layout_footerTitle__3S03g">CS Essentials by IEEE-IST CS</span></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"contentData":{"topic":"valgrind","page":"2-Memory Leaks.md","contentHtml":"\u003ch1\u003eDetecting Memory Leaks\u003c/h1\u003e\n\u003cp\u003eMemcheck keeps track of all heap blocks issued in response to calls to \u003ccode\u003emalloc\u003c/code\u003e/\u003ccode\u003enew\u003c/code\u003e (for C/C++, respectively) et al. Thus, when the program exits, Memcheck knows which blocks have not been freed.\u003c/p\u003e\n\u003ch3\u003eBasic memory leak example\u003c/h3\u003e\n\u003cp\u003eLet's consider the following code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\t\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e *my_str = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e));\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's compile it with:\n\u003ccode\u003egcc -g -o my-prog main.c\u003c/code\u003e\nBy omission, this is how we're going to compile our files going forward.\u003c/p\u003e\n\u003cp\u003eRunning the program:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evalgrind ./my-prog\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe get the following output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e...\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e== HEAP SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e==     in use at exit: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e==   total heap usage: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e allocs, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e frees, \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes allocated\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e== LEAK SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e==    definitely lost: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e==    indirectly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e==      possibly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e==    still reachable: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e==         suppressed: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e== Rerun with --leak-check=full to see details of leaked memory\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e== For counts of detected and suppressed errors, rerun with: -v\n==\u003cspan class=\"hljs-attr\"\u003e6283\u003c/span\u003e== ERROR SUMMARY: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e errors from \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e contexts (suppressed: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e from \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMemcheck lets us know about the obvious memory leak: we allocated 42 bytes, since \u003ccode\u003esizeof(char) == 1\u003c/code\u003e (section 6.5.3.5 of the specification), which we didn't free.\nValgrind recommends the use of the \u003ccode\u003e--leak-check=full\u003c/code\u003e. By using that option we'll get useful information that'll help us solve memory leaks.\u003c/p\u003e\n\u003cp\u003eLet's then rerun the program with \u003ccode\u003e--leak-check=full\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evalgrind --leak-check=full ./my-prog\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis is the output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e...\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== HEAP SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==     in use at exit: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==   total heap usage: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e allocs, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e frees, \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes allocated\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks are definitely lost in loss record \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e of \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==    at \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003ex4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==    by \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003ex10865B: main (main.c:\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== LEAK SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==    definitely lost: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==    indirectly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==      possibly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==    still reachable: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==         suppressed: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== For counts of detected and suppressed errors, rerun with: -v\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== ERROR SUMMARY: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e errors from \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e contexts (suppressed: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e from \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHow cool is this? Valgrind was able to tell us exactly where the un\u003ccode\u003efree\u003c/code\u003ed memory was! Now, this is obviously a very simple program and you can tell where the leak is right away, but that won't always be the case. I \u003cstrong\u003eassure\u003c/strong\u003e you.\u003c/p\u003e\n\u003cp\u003eLet's correct our program then!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\t\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e * my_str = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e));\n\n\t\u003cspan class=\"hljs-built_in\"\u003efree\u003c/span\u003e(my_str);\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output will now look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e...\n==\u003cspan class=\"hljs-attr\"\u003e7101\u003c/span\u003e== HEAP SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e7101\u003c/span\u003e==     in use at exit: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e7101\u003c/span\u003e==   total heap usage: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e allocs, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e frees, \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes allocated\n==\u003cspan class=\"hljs-attr\"\u003e7101\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e7101\u003c/span\u003e== All heap blocks were freed -- \u003cspan class=\"hljs-literal\"\u003eno\u003c/span\u003e leaks are possible\n==\u003cspan class=\"hljs-attr\"\u003e7101\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e7101\u003c/span\u003e== For counts of detected and suppressed errors, rerun with: -v\n==\u003cspan class=\"hljs-attr\"\u003e7101\u003c/span\u003e== ERROR SUMMARY: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e errors from \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e contexts (suppressed: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e from \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGreat, now we know how to look for memory leaks!\u003c/p\u003e\n\u003ch3\u003eKinds of memory leaks\u003c/h3\u003e\n\u003cp\u003eLet's take a look at an excerpt from the above example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e== LEAK SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==    definitely lost: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==    indirectly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==      possibly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e6303\u003c/span\u003e==    still reachable: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis little snippet includes the four types of leaks than may occur in your programs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"Still reachable\" - The block is still pointed at, so the programmer, in principle, could have freed it before program exit. They're very common, so by default won't report such blocks individually.\u003c/li\u003e\n\u003cli\u003e\"Definitely lost\" - No pointer to the block can be found. The block is classified as \"lost\" because the programmer could not possibly have freed it at program exit, since no pointer to it exists. This is a symptom of the pointer being lost at some earlier point in the program. Such cases should be fixed by the programmer.\u003c/li\u003e\n\u003cli\u003e\"Indirectly lost\" - The block is lost, not because there are no pointers to it, but rather because all the blocks that point to it are themselves lost. For example, if you have a binary tree and the root node is lost, all is children nodes will be indirectly lost.\u003c/li\u003e\n\u003cli\u003e\"Possibly lost\" - This means that one or more pointers to the block have been found, but at least one of them is an interior-pointer (i.e. a pointer to the middle of the block).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the example at the start of this section, the 42 bytes we allocated were \"definitely lost\" because, after returning from \u003ccode\u003emain\u003c/code\u003e, the lifetime of \u003ccode\u003emy_str\u003c/code\u003e ends. As a result, there is no longer a reference to the pointer to the 42 bytes of allocated memory.\u003c/p\u003e\n\u003ch3\u003e\"Definitely lost\" memory\u003c/h3\u003e\n\u003cp\u003eThe previous example demonstrated a case of \"definitely lost\" memory, but let's take a look at another example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\t\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e *my_str = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e);\n\tmy_str = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e);\n\n\t\u003cspan class=\"hljs-built_in\"\u003efree\u003c/span\u003e(my_str);\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this case, those first 42 bytes are \"definitely lost\" because the pointer value is overwritten to the newly allocated 100 bytes; and so, there is no longer any reference to the first block of memory we allocated.\u003c/p\u003e\n\u003ch3\u003e\"Still reachable\" memory\u003c/h3\u003e\n\u003cp\u003eSometimes, this kind of leak is confused with \"definitely lost\" memory because one might think that (considering the first example in this section) \u003ccode\u003emy_str\u003c/code\u003e, the pointer to the allocated memory, could have been used to free it.\u003c/p\u003e\n\u003cp\u003eHowever, the program doesn't end with \u003ccode\u003emain\u003c/code\u003e returning. After \u003ccode\u003emain\u003c/code\u003e returning, both global and static variables still live on, thus allowing cleanup routines (such as \u003ca href=\"https://www.man7.org/linux/man-pages/man3/atexit.3.html\"\u003e\u003ccode\u003eatexit\u003c/code\u003e\u003c/a\u003e) to clean up memory pointed to by those variables. Let's take a look at an example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e *my_str;\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\tmy_str = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e);\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eValgrind tells us this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e...\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e== HEAP SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e==     in use at exit: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e==   total heap usage: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e allocs, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e frees, \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes allocated\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e== LEAK SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e==    definitely lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e==    indirectly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e==      possibly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e==    still reachable: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e25767\u003c/span\u003e==         suppressed: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince \u003ccode\u003emy_str\u003c/code\u003e is a global variable, it is still \"alive\" after \u003ccode\u003emain\u003c/code\u003e returning, so we still have a reference to the allocated 42 bytes. We can free that memory after returning from \u003ccode\u003emain\u003c/code\u003e by using a method such as the aforementioned \u003ccode\u003eatexit\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e *my_str;\n\n\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003ecleanup\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n\t\u003cspan class=\"hljs-built_in\"\u003efree\u003c/span\u003e(my_str);\n}\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\tatexit(cleanup);\n\n\tmy_str = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e);\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\"Possibly lost\" memory\u003c/h3\u003e\n\u003cp\u003eAs stated before, what causes Valgrind to tell us about \"possibly lost\" memory is the existance of an interior-pointer to an allocated block.\u003c/p\u003e\n\u003cp\u003eThat can be the result of libraries which have their own allocators and for which the pointer to the allocated memory is not the pointer returned by the OS itself (via the \u003ccode\u003emalloc\u003c/code\u003e library function or the \u003ccode\u003esbrk\u003c/code\u003e system call) but a pointer with some offset.\u003c/p\u003e\n\u003cp\u003eAn example of a program that produces such a warning from Valgrind is as such:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e *my_str;\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\tmy_str = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e);\n\t\u003cspan class=\"hljs-comment\"\u003e/* At this point, the pointer points to the start\n\tof the allocated memory. */\u003c/span\u003e\n\n\tmy_str += \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e;\n\t\u003cspan class=\"hljs-comment\"\u003e/* At this point, no pointer points to the start of\n\tthe allocated memory. However, it is still accessible. */\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eValgrind tells us about the \"possibly lost\" memory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e...\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e== HEAP SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==     in use at exit: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==   total heap usage: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e allocs, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e frees, \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes allocated\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e== \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks are possibly lost in loss record \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e of \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==    at \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003ex4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==    by \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003ex108657: main (main.c:\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e)\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e== LEAK SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==    definitely lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==    indirectly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==      possibly lost: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==    still reachable: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e29630\u003c/span\u003e==         suppressed: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo free a memory block we need the address of that memory block. So in this case, all we have to do is take into the pointer offset and get to the start of the allocated block:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e *my_str;\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\tmy_str = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e);\n\t\u003cspan class=\"hljs-comment\"\u003e/* At this point, the pointer points to the start\n\tof the allocated memory. */\u003c/span\u003e\n\n\tmy_str += \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e;\n\t\u003cspan class=\"hljs-comment\"\u003e/* At this point, no pointer points to the start of\n\tthe allocated memory. However, it is still accessible. */\u003c/span\u003e\n\n\t\u003cspan class=\"hljs-built_in\"\u003efree\u003c/span\u003e(my_str - \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e);\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd now the leak is gone!\u003c/p\u003e\n\u003ch3\u003e\"Indirectly lost\"\u003c/h3\u003e\n\u003cp\u003eReiterating on what was said up there, \"indirectly lost\" memory doesn't mean that there are no pointers to it, but rather because all the blocks that point to it are themselves lost.\u003c/p\u003e\n\u003cp\u003eHere is a simple example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e ***arr;\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\tarr = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e**));\n\n\tarr[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e*));\n\n\tarr[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e));\n\n\t\u003cspan class=\"hljs-built_in\"\u003efree\u003c/span\u003e(arr);\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich produces the following output in Valgrind:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ini\"\u003e...\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e== HEAP SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==     in use at exit: \u003cspan class=\"hljs-number\"\u003e440\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==   total heap usage: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e allocs, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e frees, \u003cspan class=\"hljs-number\"\u003e480\u003c/span\u003e bytes allocated\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e== \u003cspan class=\"hljs-number\"\u003e440\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e direct, \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e indirect) bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks are definitely lost in loss record \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e of \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==    at \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003ex4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==    by \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003ex1086B8: main (main.c:\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e)\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e== \n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e== LEAK SUMMARY:\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==    definitely lost: \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==    indirectly lost: \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==      possibly lost: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==    still reachable: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n==\u003cspan class=\"hljs-attr\"\u003e30154\u003c/span\u003e==         suppressed: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e bytes in \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e blocks\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can fix this by appropriately freeing the allocated blocks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-c\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;stdlib.h\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e ***arr;\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title hljs-function\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n\tarr = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e**));\n\n\tarr[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e*));\n\n\tarr[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] = \u003cspan class=\"hljs-built_in\"\u003emalloc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e));\n\n\t\u003cspan class=\"hljs-built_in\"\u003efree\u003c/span\u003e(arr[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]);\n\t\u003cspan class=\"hljs-built_in\"\u003efree\u003c/span\u003e(arr[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]);\n\t\u003cspan class=\"hljs-built_in\"\u003efree\u003c/span\u003e(arr);\n\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere you go, now you should have the tools to check your programs for memory leaks!\u003c/p\u003e"},"topicPages":[{"topic":"valgrind","page":"Introduction"},{"topic":"valgrind","page":"Basic Example"},{"topic":"valgrind","page":"Memory Leaks"}]},"__N_SSG":true},"page":"/content/[topic]/[page]","query":{"topic":"valgrind","page":"Memory Leaks"},"buildId":"LYyRVvNwNYLo0ckHfDevq","assetPrefix":"/cs-essentials","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>