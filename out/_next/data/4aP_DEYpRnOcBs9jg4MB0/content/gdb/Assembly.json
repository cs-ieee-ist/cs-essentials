{"pageProps":{"contentData":{"topic":"gdb","page":"4-Assembly.md","contentHtml":"<h1>GDB - Assembly</h1>\n<p>There are several occasions where you need to debug at the assembler level. It can be, for example, to understand how the compiler is generating your code and how that code is behaving.</p>\n<h2>Machine Language related commands</h2>\n<p>Before we start going through an example, we need to introduce some Assembly related commands:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Short version</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>info line</td>\n<td></td>\n<td>Displays the start and end position of the compiled code for the current line</td>\n</tr>\n<tr>\n<td>info line number</td>\n<td></td>\n<td>Display position in object code for a specified line</td>\n</tr>\n<tr>\n<td>disassemble <em>start_address</em>  <em>end_address</em></td>\n<td></td>\n<td>Displays machine code for positions in object code specified, start and end memory values are optional</td>\n</tr>\n<tr>\n<td>stepi</td>\n<td>si</td>\n<td>step assembly instruction</td>\n</tr>\n<tr>\n<td>nexti</td>\n<td>ni</td>\n<td>next assembly instruction</td>\n</tr>\n<tr>\n<td>x <em>address</em></td>\n<td></td>\n<td>Examine the contents of memory</td>\n</tr>\n<tr>\n<td>x/nfu <em>address</em></td>\n<td></td>\n<td>Examine the contents of memory with a specific format. n: number of display items to print (default is 1), f: specify the format for the output i - instr, s-string, x-hex, d-sdecimal, u-udecimal, o-octal, t-binary, a-addr, c-char ,f-float, u: specify the size of the data unit b-byte, h-halfword, w-word, g-giant (8 bytes)</td>\n</tr>\n</tbody>\n</table>\n<h2>Debug</h2>\n<p><strong>Program</strong></p>\n<pre><code class=\"language-c\">#include &#x3C;stdio.h>\r\n\r\nint main() {\r\n      int a = 1;\r\n      a = a + 2;  \r\n      printf(\"a: %d\\n\", a);\r\n    return 0;\r\n}\n</code></pre>\n<p><strong>Compile and open GDB</strong></p>\n<pre><code class=\"language-shell\">$ gcc -g hello.c\r\n$ gdb ./a.out\n</code></pre>\n<p><strong>Start execution</strong></p>\n<pre><code class=\"language-shell\">(gdb) b main\r\n(gdb) r\n</code></pre>\n<p>So far everything we have done is just the usual setup. Now we want to start analysing the machine code. You can find the Assembly code specific commands at the table above. To start let's display the start and end memory position of the current line.</p>\n<pre><code class=\"language-shell\">(gdb) info line\r\nLine 3 of \"hello.c\" starts at address 0x8001149 &#x3C;main> and ends at 0x8001155 &#x3C;main+12>.\n</code></pre>\n<p>We can also display the compiled code that corresponds to the \"main\" function.</p>\n<pre><code class=\"language-shell\">(gdb) disassemble\r\n=> 0x0000000008001149 &#x3C;+0>:     endbr64\r\n   0x000000000800114d &#x3C;+4>:     push   %rbp\r\n   0x000000000800114e &#x3C;+5>:     mov    %rsp,%rbp\r\n   0x0000000008001151 &#x3C;+8>:     sub    $0x10,%rsp\r\n   0x0000000008001155 &#x3C;+12>:    movl   $0x1,-0x4(%rbp)\r\n   0x000000000800115c &#x3C;+19>:    addl   $0x2,-0x4(%rbp)\r\n   0x0000000008001160 &#x3C;+23>:    mov    -0x4(%rbp),%eax\r\n   0x0000000008001163 &#x3C;+26>:    mov    %eax,%esi\r\n   0x0000000008001165 &#x3C;+28>:    lea    0xe98(%rip),%rdi        # 0x8002004\r\n   0x000000000800116c &#x3C;+35>:    mov    $0x0,%eax\r\n   0x0000000008001171 &#x3C;+40>:    callq  0x8001050 &#x3C;printf@plt>\r\n   0x0000000008001176 &#x3C;+45>:    mov    $0x0,%eax\r\n   0x000000000800117b &#x3C;+50>:    leaveq\r\n   0x000000000800117c &#x3C;+51>:    retq\n</code></pre>\n<p>Now we can follow the execution one instruction at a time using the \"stepi\" command.</p>\n<pre><code class=\"language-shell\">(gdb) stepi\r\n(gdb) disassemble\r\n   0x0000000008001149 &#x3C;+0>:     endbr64\r\n=> 0x000000000800114d &#x3C;+4>:     push   %rbp\r\n   0x000000000800114e &#x3C;+5>:     mov    %rsp,%rbp\r\n   0x0000000008001151 &#x3C;+8>:     sub    $0x10,%rsp\r\n   0x0000000008001155 &#x3C;+12>:    movl   $0x1,-0x4(%rbp)\r\n   0x000000000800115c &#x3C;+19>:    addl   $0x2,-0x4(%rbp)\r\n   0x0000000008001160 &#x3C;+23>:    mov    -0x4(%rbp),%eax\r\n   0x0000000008001163 &#x3C;+26>:    mov    %eax,%esi\r\n   0x0000000008001165 &#x3C;+28>:    lea    0xe98(%rip),%rdi        # 0x8002004\r\n   0x000000000800116c &#x3C;+35>:    mov    $0x0,%eax\r\n   0x0000000008001171 &#x3C;+40>:    callq  0x8001050 &#x3C;printf@plt>\r\n   0x0000000008001176 &#x3C;+45>:    mov    $0x0,%eax\r\n   0x000000000800117b &#x3C;+50>:    leaveq\r\n   0x000000000800117c &#x3C;+51>:    retq\n</code></pre>\n<p>To finish we can set a new breakpoint at the line where we add plus 2 to the \"a\" variable and watch the value at the memory address change.</p>\n<pre><code class=\"language-shell\">(gdb) b 5\r\n(gdb) c\r\n(gdb) p &#x26;a\r\n$3 = (int *) 0x7ffffffedebc\r\n(gdb) x/1d 0x7ffffffedebc\r\n0x7ffffffedebc: 1\r\n(gdb) x/1d 0x7ffffffedebc\r\n0x7ffffffedebc: 3\n</code></pre>"},"topicPages":[{"topic":"gdb","page":"Introduction"},{"topic":"gdb","page":"Commands"},{"topic":"gdb","page":"Core Files"},{"topic":"gdb","page":"GUI"},{"topic":"gdb","page":"Assembly"}]},"__N_SSG":true}