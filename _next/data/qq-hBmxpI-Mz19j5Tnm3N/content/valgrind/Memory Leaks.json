{"pageProps":{"contentData":{"topic":"valgrind","page":"2-Memory Leaks.md","contentHtml":"<h1>Detecting Memory Leaks</h1>\n<p>Memcheck keeps track of all heap blocks issued in response to calls to <code>malloc</code>/<code>new</code> (for C/C++, respectively) et al. Thus, when the program exits, Memcheck knows which blocks have not been freed.</p>\n<h3>Basic memory leak example</h3>\n<p>Let's consider the following code:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\t<span class=\"hljs-type\">char</span> *my_str = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">char</span>));\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<p>Let's compile it with:\r\n<code>gcc -g -o my-prog main.c</code>\r\nBy omission, this is how we're going to compile our files going forward.</p>\n<p>Running the program:</p>\n<p><code>valgrind ./my-prog</code></p>\n<p>We get the following output:</p>\n<pre><code class=\"hljs language-ini\">...\r\n==<span class=\"hljs-attr\">6283</span>== HEAP SUMMARY:\r\n==<span class=\"hljs-attr\">6283</span>==     in use at exit: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">6283</span>==   total heap usage: <span class=\"hljs-number\">1</span> allocs, <span class=\"hljs-number\">0</span> frees, <span class=\"hljs-number\">42</span> bytes allocated\r\n==<span class=\"hljs-attr\">6283</span>== \r\n==<span class=\"hljs-attr\">6283</span>== LEAK SUMMARY:\r\n==<span class=\"hljs-attr\">6283</span>==    definitely lost: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">6283</span>==    indirectly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6283</span>==      possibly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6283</span>==    still reachable: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6283</span>==         suppressed: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6283</span>== Rerun with --leak-check=full to see details of leaked memory\r\n==<span class=\"hljs-attr\">6283</span>== \r\n==<span class=\"hljs-attr\">6283</span>== For counts of detected and suppressed errors, rerun with: -v\r\n==<span class=\"hljs-attr\">6283</span>== ERROR SUMMARY: <span class=\"hljs-number\">0</span> errors from <span class=\"hljs-number\">0</span> contexts (suppressed: <span class=\"hljs-number\">0</span> from <span class=\"hljs-number\">0</span>)\r\n...\n</code></pre>\n<p>Memcheck lets us know about the obvious memory leak: we allocated 42 bytes, since <code>sizeof(char) == 1</code> (section 6.5.3.5 of the specification), which we didn't free.\r\nValgrind recommends the use of the <code>--leak-check=full</code>. By using that option we'll get useful information that'll help us solve memory leaks.</p>\n<p>Let's then rerun the program with <code>--leak-check=full</code>:</p>\n<p><code>valgrind --leak-check=full ./my-prog</code></p>\n<p>This is the output:</p>\n<pre><code class=\"hljs language-ini\">...\r\n==<span class=\"hljs-attr\">6303</span>== HEAP SUMMARY:\r\n==<span class=\"hljs-attr\">6303</span>==     in use at exit: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>==   total heap usage: <span class=\"hljs-number\">1</span> allocs, <span class=\"hljs-number\">0</span> frees, <span class=\"hljs-number\">42</span> bytes allocated\r\n==<span class=\"hljs-attr\">6303</span>== \r\n==<span class=\"hljs-attr\">6303</span>== <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks are definitely lost in loss record <span class=\"hljs-number\">1</span> of <span class=\"hljs-number\">1</span>\r\n==<span class=\"hljs-attr\">6303</span>==    at <span class=\"hljs-number\">0</span>x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==<span class=\"hljs-attr\">6303</span>==    by <span class=\"hljs-number\">0</span>x10865B: main (main.c:<span class=\"hljs-number\">5</span>)\r\n==<span class=\"hljs-attr\">6303</span>== \r\n==<span class=\"hljs-attr\">6303</span>== LEAK SUMMARY:\r\n==<span class=\"hljs-attr\">6303</span>==    definitely lost: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>==    indirectly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>==      possibly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>==    still reachable: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>==         suppressed: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>== \r\n==<span class=\"hljs-attr\">6303</span>== For counts of detected and suppressed errors, rerun with: -v\r\n==<span class=\"hljs-attr\">6303</span>== ERROR SUMMARY: <span class=\"hljs-number\">1</span> errors from <span class=\"hljs-number\">1</span> contexts (suppressed: <span class=\"hljs-number\">0</span> from <span class=\"hljs-number\">0</span>)\r\n...\n</code></pre>\n<p>How cool is this? Valgrind was able to tell us exactly where the un<code>free</code>d memory was! Now, this is obviously a very simple program and you can tell where the leak is right away, but that won't always be the case. I <strong>assure</strong> you.</p>\n<p>Let's correct our program then!</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\t<span class=\"hljs-type\">char</span> * my_str = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">char</span>));\r\n\r\n\t<span class=\"hljs-built_in\">free</span>(my_str);\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<p>The output will now look like this:</p>\n<pre><code class=\"hljs language-ini\">...\r\n==<span class=\"hljs-attr\">7101</span>== HEAP SUMMARY:\r\n==<span class=\"hljs-attr\">7101</span>==     in use at exit: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">7101</span>==   total heap usage: <span class=\"hljs-number\">1</span> allocs, <span class=\"hljs-number\">1</span> frees, <span class=\"hljs-number\">42</span> bytes allocated\r\n==<span class=\"hljs-attr\">7101</span>== \r\n==<span class=\"hljs-attr\">7101</span>== All heap blocks were freed -- <span class=\"hljs-literal\">no</span> leaks are possible\r\n==<span class=\"hljs-attr\">7101</span>== \r\n==<span class=\"hljs-attr\">7101</span>== For counts of detected and suppressed errors, rerun with: -v\r\n==<span class=\"hljs-attr\">7101</span>== ERROR SUMMARY: <span class=\"hljs-number\">0</span> errors from <span class=\"hljs-number\">0</span> contexts (suppressed: <span class=\"hljs-number\">0</span> from <span class=\"hljs-number\">0</span>)\r\n...\n</code></pre>\n<p>Great, now we know how to look for memory leaks!</p>\n<h3>Kinds of memory leaks</h3>\n<p>Let's take a look at an excerpt from the above example:</p>\n<pre><code class=\"hljs language-ini\">==<span class=\"hljs-attr\">6303</span>== LEAK SUMMARY:\r\n==<span class=\"hljs-attr\">6303</span>==    definitely lost: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>==    indirectly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>==      possibly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">6303</span>==    still reachable: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\n</code></pre>\n<p>This little snippet includes the four types of leaks than may occur in your programs:</p>\n<ul>\n<li>\"Still reachable\" - The block is still pointed at, so the programmer, in principle, could have freed it before program exit. They're very common, so by default won't report such blocks individually.</li>\n<li>\"Definitely lost\" - No pointer to the block can be found. The block is classified as \"lost\" because the programmer could not possibly have freed it at program exit, since no pointer to it exists. This is a symptom of the pointer being lost at some earlier point in the program. Such cases should be fixed by the programmer.</li>\n<li>\"Indirectly lost\" - The block is lost, not because there are no pointers to it, but rather because all the blocks that point to it are themselves lost. For example, if you have a binary tree and the root node is lost, all is children nodes will be indirectly lost.</li>\n<li>\"Possibly lost\" - This means that one or more pointers to the block have been found, but at least one of them is an interior-pointer (i.e. a pointer to the middle of the block).</li>\n</ul>\n<p>In the example at the start of this section, the 42 bytes we allocated were \"definitely lost\" because, after returning from <code>main</code>, the lifetime of <code>my_str</code> ends. As a result, there is no longer a reference to the pointer to the 42 bytes of allocated memory.</p>\n<h3>\"Definitely lost\" memory</h3>\n<p>The previous example demonstrated a case of \"definitely lost\" memory, but let's take a look at another example:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\t<span class=\"hljs-type\">char</span> *my_str = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span>);\r\n\tmy_str = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">100</span>);\r\n\r\n\t<span class=\"hljs-built_in\">free</span>(my_str);\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<p>In this case, those first 42 bytes are \"definitely lost\" because the pointer value is overwritten to the newly allocated 100 bytes; and so, there is no longer any reference to the first block of memory we allocated.</p>\n<h3>\"Still reachable\" memory</h3>\n<p>Sometimes, this kind of leak is confused with \"definitely lost\" memory because one might think that (considering the first example in this section) <code>my_str</code>, the pointer to the allocated memory, could have been used to free it.</p>\n<p>However, the program doesn't end with <code>main</code> returning. After <code>main</code> returning, both global and static variables still live on, thus allowing cleanup routines (such as <a href=\"https://www.man7.org/linux/man-pages/man3/atexit.3.html\"><code>atexit</code></a>) to clean up memory pointed to by those variables. Let's take a look at an example:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">char</span> *my_str;\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\tmy_str = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span>);\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<p>Valgrind tells us this:</p>\n<pre><code class=\"hljs language-ini\">...\r\n==<span class=\"hljs-attr\">25767</span>== HEAP SUMMARY:\r\n==<span class=\"hljs-attr\">25767</span>==     in use at exit: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">25767</span>==   total heap usage: <span class=\"hljs-number\">1</span> allocs, <span class=\"hljs-number\">0</span> frees, <span class=\"hljs-number\">42</span> bytes allocated\r\n==<span class=\"hljs-attr\">25767</span>== \r\n==<span class=\"hljs-attr\">25767</span>== LEAK SUMMARY:\r\n==<span class=\"hljs-attr\">25767</span>==    definitely lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">25767</span>==    indirectly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">25767</span>==      possibly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">25767</span>==    still reachable: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">25767</span>==         suppressed: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n...\n</code></pre>\n<p>Since <code>my_str</code> is a global variable, it is still \"alive\" after <code>main</code> returning, so we still have a reference to the allocated 42 bytes. We can free that memory after returning from <code>main</code> by using a method such as the aforementioned <code>atexit</code>:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">char</span> *my_str;\r\n\r\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title hljs-function\">cleanup</span><span class=\"hljs-params\">()</span> {\r\n\t<span class=\"hljs-built_in\">free</span>(my_str);\r\n}\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\tatexit(cleanup);\r\n\r\n\tmy_str = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span>);\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<h3>\"Possibly lost\" memory</h3>\n<p>As stated before, what causes Valgrind to tell us about \"possibly lost\" memory is the existance of an interior-pointer to an allocated block.</p>\n<p>That can be the result of libraries which have their own allocators and for which the pointer to the allocated memory is not the pointer returned by the OS itself (via the <code>malloc</code> library function or the <code>sbrk</code> system call) but a pointer with some offset.</p>\n<p>An example of a program that produces such a warning from Valgrind is as such:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">char</span> *my_str;\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\tmy_str = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span>);\r\n\t<span class=\"hljs-comment\">/* At this point, the pointer points to the start\r\n\tof the allocated memory. */</span>\r\n\r\n\tmy_str += <span class=\"hljs-number\">20</span>;\r\n\t<span class=\"hljs-comment\">/* At this point, no pointer points to the start of\r\n\tthe allocated memory. However, it is still accessible. */</span>\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<p>Valgrind tells us about the \"possibly lost\" memory:</p>\n<pre><code class=\"hljs language-ini\">...\r\n==<span class=\"hljs-attr\">29630</span>== HEAP SUMMARY:\r\n==<span class=\"hljs-attr\">29630</span>==     in use at exit: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">29630</span>==   total heap usage: <span class=\"hljs-number\">1</span> allocs, <span class=\"hljs-number\">0</span> frees, <span class=\"hljs-number\">42</span> bytes allocated\r\n==<span class=\"hljs-attr\">29630</span>== \r\n==<span class=\"hljs-attr\">29630</span>== <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks are possibly lost in loss record <span class=\"hljs-number\">1</span> of <span class=\"hljs-number\">1</span>\r\n==<span class=\"hljs-attr\">29630</span>==    at <span class=\"hljs-number\">0</span>x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==<span class=\"hljs-attr\">29630</span>==    by <span class=\"hljs-number\">0</span>x108657: main (main.c:<span class=\"hljs-number\">7</span>)\r\n==<span class=\"hljs-attr\">29630</span>== \r\n==<span class=\"hljs-attr\">29630</span>== LEAK SUMMARY:\r\n==<span class=\"hljs-attr\">29630</span>==    definitely lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">29630</span>==    indirectly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">29630</span>==      possibly lost: <span class=\"hljs-number\">42</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">29630</span>==    still reachable: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">29630</span>==         suppressed: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n...\n</code></pre>\n<p>To free a memory block we need the address of that memory block. So in this case, all we have to do is take into the pointer offset and get to the start of the allocated block:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">char</span> *my_str;\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\tmy_str = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">42</span>);\r\n\t<span class=\"hljs-comment\">/* At this point, the pointer points to the start\r\n\tof the allocated memory. */</span>\r\n\r\n\tmy_str += <span class=\"hljs-number\">20</span>;\r\n\t<span class=\"hljs-comment\">/* At this point, no pointer points to the start of\r\n\tthe allocated memory. However, it is still accessible. */</span>\r\n\r\n\t<span class=\"hljs-built_in\">free</span>(my_str - <span class=\"hljs-number\">20</span>);\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<p>And now the leak is gone!</p>\n<h3>\"Indirectly lost\"</h3>\n<p>Reiterating on what was said up there, \"indirectly lost\" memory doesn't mean that there are no pointers to it, but rather because all the blocks that point to it are themselves lost.</p>\n<p>Here is a simple example:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">int</span> ***arr;\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\tarr = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">5</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>**));\r\n\r\n\tarr[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">5</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>*));\r\n\r\n\tarr[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">100</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>));\r\n\r\n\t<span class=\"hljs-built_in\">free</span>(arr);\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<p>Which produces the following output in Valgrind:</p>\n<pre><code class=\"hljs language-ini\">...\r\n==<span class=\"hljs-attr\">30154</span>== HEAP SUMMARY:\r\n==<span class=\"hljs-attr\">30154</span>==     in use at exit: <span class=\"hljs-number\">440</span> bytes in <span class=\"hljs-number\">2</span> blocks\r\n==<span class=\"hljs-attr\">30154</span>==   total heap usage: <span class=\"hljs-number\">3</span> allocs, <span class=\"hljs-number\">1</span> frees, <span class=\"hljs-number\">480</span> bytes allocated\r\n==<span class=\"hljs-attr\">30154</span>== \r\n==<span class=\"hljs-attr\">30154</span>== <span class=\"hljs-number\">440</span> (<span class=\"hljs-number\">40</span> direct, <span class=\"hljs-number\">400</span> indirect) bytes in <span class=\"hljs-number\">1</span> blocks are definitely lost in loss record <span class=\"hljs-number\">2</span> of <span class=\"hljs-number\">2</span>\r\n==<span class=\"hljs-attr\">30154</span>==    at <span class=\"hljs-number\">0</span>x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==<span class=\"hljs-attr\">30154</span>==    by <span class=\"hljs-number\">0</span>x1086B8: main (main.c:<span class=\"hljs-number\">9</span>)\r\n==<span class=\"hljs-attr\">30154</span>== \r\n==<span class=\"hljs-attr\">30154</span>== LEAK SUMMARY:\r\n==<span class=\"hljs-attr\">30154</span>==    definitely lost: <span class=\"hljs-number\">40</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">30154</span>==    indirectly lost: <span class=\"hljs-number\">400</span> bytes in <span class=\"hljs-number\">1</span> blocks\r\n==<span class=\"hljs-attr\">30154</span>==      possibly lost: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">30154</span>==    still reachable: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n==<span class=\"hljs-attr\">30154</span>==         suppressed: <span class=\"hljs-number\">0</span> bytes in <span class=\"hljs-number\">0</span> blocks\r\n...\n</code></pre>\n<p>We can fix this by appropriately freeing the allocated blocks:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\r\n\r\n<span class=\"hljs-type\">int</span> ***arr;\r\n\r\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title hljs-function\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>\r\n{\r\n\tarr = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">5</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>**));\r\n\r\n\tarr[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">5</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>*));\r\n\r\n\tarr[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">100</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>));\r\n\r\n\t<span class=\"hljs-built_in\">free</span>(arr[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">2</span>]);\r\n\t<span class=\"hljs-built_in\">free</span>(arr[<span class=\"hljs-number\">2</span>]);\r\n\t<span class=\"hljs-built_in\">free</span>(arr);\r\n\r\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\n</code></pre>\n<p>There you go, now you should have the tools to check your programs for memory leaks!</p>"},"topicPages":[{"topic":"valgrind","page":"Introduction"},{"topic":"valgrind","page":"Basic Example"},{"topic":"valgrind","page":"Memory Leaks"}]},"__N_SSG":true}